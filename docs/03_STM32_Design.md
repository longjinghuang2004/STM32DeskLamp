
# STM32 固件结构与早期设计反思

STM32 端作为项目的早期产物，主要采用裸机（无 RTOS）的前后台架构，依靠 SysTick 提供系统节拍，依靠中断处理高实时性任务。

## 1. 关键算法实现

### 1.1 双色温 PWM 混光算法
在 `LightCtrl.c` 中，系统将抽象的“亮度 (0-1000)”和“色温 (0-1000)”映射为物理的暖光和冷光 PWM 占空比：
*   `warm = (1.0 - cct_factor) * 1000 * bri_factor`
*   `cold = cct_factor * 1000 * bri_factor`
该算法保证了在调节色温时，总光通量（视觉亮度）基本保持恒定。

### 1.2 PAJ7620 手势反向滤波
手势传感器在用户挥手复位时容易产生误触发（例如：向左挥手后，手收回时被识别为向右）。
在 `PAJ7620.c` 中引入了**反向手势滤波 (Anti-Rebound Filter)**：
记录上一次的有效手势和时间戳，如果在 `PAJ_REVERSE_FILTER_TIME` (600ms) 内检测到完全相反的手势，则将其丢弃。

### 1.3 KeyManager 多键与连击状态机
重构后的 `KeyManager.c` 支持单击、双击、三击和长按。其核心是一个基于时间窗口的状态机：
*   按下后进入 `PRESSING` 态，若保持超过 800ms 则触发 `HOLD_START`。
*   松开后不立即结算，而是进入 `MULTI_WAIT` 态（250ms 窗口），若再次按下则连击数 +1，超时则根据连击数结算事件。

## 2. 架构反思与技术债 (Legacy Reflection)

作为早期设计，STM32 端代码在软件工程层面存在以下不足，这也是后续重构的重点：

1.  **业务与驱动耦合过深**:
    在 `ControlManager.c` 中，直接包含了 `PAJ7620_GESTURE_UP` 等硬件宏定义，并直接调用 `LightCtrl_SetRawPWM`。理想的设计应该是：传感器驱动只抛出标准化的输入事件，由一个独立的“规则引擎”来映射输入与输出。
2.  **缺乏统一的 HAL 抽象**:
    代码中大量直接调用了 STM32 标准外设库（如 `TIM_SetCompare1`）。如果未来需要将小脑更换为其他 MCU（如 CH32 或 ESP32-C3），移植成本较高。
3.  **全局变量滥用**:
    虽然引入了 `SystemModel.h` 作为数据中心，但各模块对其的访问缺乏并发保护（虽然在裸机单线程下不会出错，但在中断抢占时存在隐患）。
